[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OverHAuL",
    "section": "",
    "text": "Preface\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\nNunc ac dignissim magna. Vestibulum vitae egestas elit. Proin feugiat leo quis ante condimentum, eu ornare mauris feugiat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris cursus laoreet ex, dignissim bibendum est posuere iaculis. Suspendisse et maximus elit. In fringilla gravida ornare. Aenean id lectus pulvinar, sagittis felis nec, rutrum risus. Nam vel neque eu arcu blandit fringilla et in quam. Aliquam luctus est sit amet vestibulum eleifend. Phasellus elementum sagittis molestie. Proin tempor lorem arcu, at condimentum purus volutpat eu. Fusce et pellentesque ligula. Pellentesque id tellus at erat luctus fringilla. Suspendisse potenti.\nEtiam maximus accumsan gravida. Maecenas at nunc dignissim, euismod enim ac, bibendum ipsum. Maecenas vehicula velit in nisl aliquet ultricies. Nam eget massa interdum, maximus arcu vel, pretium erat. Maecenas sit amet tempor purus, vitae aliquet nunc. Vivamus cursus urna velit, eleifend dictum magna laoreet ut. Duis eu erat mollis, blandit magna id, tincidunt ipsum. Integer massa nibh, commodo eu ex vel, venenatis efficitur ligula. Integer convallis lacus elit, maximus eleifend lacus ornare ac. Vestibulum scelerisque viverra urna id lacinia. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aenean eget enim at diam bibendum tincidunt eu non purus. Nullam id magna ultrices, sodales metus viverra, tempus turpis.\n\n\n\nAcknowledgments\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n\n\n\n\n\n\nCitation\n\n\n\nBibTeX citation:\n\n@thesis{chousos2025,\n  title = {LLM-Driven Fuzzing: Automatic Harness Generation for Crypto Libraries},\n  shorttitle = {LLM-Driven Fuzzing},\n  author = {Chousos, Konstantinos},\n  date = {2025-07},\n  institution = {{National and Kapodistrian University of Athens}},\n  location = {Athens, Greece},\n  url = {https://kchousos.github.io/thesis/},\n  langid = {en, el}\n}\n\nFor attribution, please cite this work as:\n\n\nK. Chousos, “LLM-Driven Fuzzing: Automatic Harness Generation for Crypto Libraries,” Bachelor Thesis, National and Kapodistrian University of Athens, Athens, Greece, 2025. [Online]. Available: https://kchousos.github.io/thesis/",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/intro.html",
    "href": "chapters/intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Motivation\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\nNunc ac dignissim magna. Vestibulum vitae egestas elit. Proin feugiat leo quis ante condimentum, eu ornare mauris feugiat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris cursus laoreet ex, dignissim bibendum est posuere iaculis. Suspendisse et maximus elit. In fringilla gravida ornare. Aenean id lectus pulvinar, sagittis felis nec, rutrum risus. Nam vel neque eu arcu blandit fringilla et in quam. Aliquam luctus est sit amet vestibulum eleifend. Phasellus elementum sagittis molestie. Proin tempor lorem arcu, at condimentum purus volutpat eu. Fusce et pellentesque ligula. Pellentesque id tellus at erat luctus fringilla. Suspendisse potenti.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\nNunc ac dignissim magna. Vestibulum vitae egestas elit. Proin feugiat leo quis ante condimentum, eu ornare mauris feugiat. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Mauris cursus laoreet ex, dignissim bibendum est posuere iaculis. Suspendisse et maximus elit. In fringilla gravida ornare. Aenean id lectus pulvinar, sagittis felis nec, rutrum risus. Nam vel neque eu arcu blandit fringilla et in quam. Aliquam luctus est sit amet vestibulum eleifend. Phasellus elementum sagittis molestie. Proin tempor lorem arcu, at condimentum purus volutpat eu. Fusce et pellentesque ligula. Pellentesque id tellus at erat luctus fringilla. Suspendisse potenti.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#preview-of-following-sections-rename",
    "href": "chapters/intro.html#preview-of-following-sections-rename",
    "title": "1  Introduction",
    "section": "1.2 Preview of following sections (rename)",
    "text": "1.2 Preview of following sections (rename)\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/background.html",
    "href": "chapters/background.html",
    "title": "2  Background",
    "section": "",
    "text": "2.1 Fuzzing\nquarto definitions\nWhat is fuzzing [1].\nterminology: fuzz campaign, harness, driver, target, corpus\nWhy fuzz?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Background</span>"
    ]
  },
  {
    "objectID": "chapters/background.html#fuzzing",
    "href": "chapters/background.html#fuzzing",
    "title": "2  Background",
    "section": "",
    "text": "2.1.1 Fuzzing examples\nHeartbleed [2], shellshock [3].\n\n\n2.1.2 Fuzzer engines\nC/C++: AFL [4] & AFL++ [4], ++. LibFuzzer [5].\nPython: Atheris [6].\nJava, Rust etc…\nAn example of a fuzz target/harness can be seen in Listing 2.1 [5].\n\n\n\nListing 2.1: A simple function that does something interesting if it receives the input “HI!”.\n\n\ncat &lt;&lt; EOF &gt; test_fuzzer.cc\n#include &lt;stdint.h&gt;\n#include &lt;stddef.h&gt;\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  if (size &gt; 0 && data[0] == 'H')\n    if (size &gt; 1 && data[1] == 'I')\n       if (size &gt; 2 && data[2] == '!')\n       __builtin_trap();\n  return 0;\n}\nEOF\n# Build test_fuzzer.cc with asan and link against libFuzzer.\nclang++ -fsanitize=address,fuzzer test_fuzzer.cc\n# Run the fuzzer with no corpus.\n./a.out\n\n\n\nOSS-Fuzz: 2016, after heartbleed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Background</span>"
    ]
  },
  {
    "objectID": "chapters/background.html#large-language-models-llms",
    "href": "chapters/background.html#large-language-models-llms",
    "title": "2  Background",
    "section": "2.2 Large Language Models (LLMs)",
    "text": "2.2 Large Language Models (LLMs)\nTransformers [7], 2017–2025. ChatGPT/OpenAI history & context. Claude, Llama (1–3) etc.\n\n2.2.1 Prompting\nPrompting techniques.\n\nZero-shot.\nOne-shot.\nChain of Thought [8].\nReACt [9].\nTree of Thoughts [10].\n\nComparison, strengths weaknesses etc. [11].\n[12]\n\n\n2.2.2 LLM Programming Libraries (?)\nLangchain & LangGraph, LlamaIndex [13], [14], [15]. DSPy [16].\nComparison, relevance to our usecase.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Background</span>"
    ]
  },
  {
    "objectID": "chapters/background.html#neurosymbolic-ai",
    "href": "chapters/background.html#neurosymbolic-ai",
    "title": "2  Background",
    "section": "2.3 Neurosymbolic AI",
    "text": "2.3 Neurosymbolic AI\nTODO [17], [18], [19], [20], [21], [22].\n\n\n\n\n[1] V. J. M. Manes et al., “The Art, Science, and Engineering of Fuzzing: A Survey,” Apr. 07, 2019. doi: 10.48550/arXiv.1812.00140. Available: http://arxiv.org/abs/1812.00140\n\n\n[2] “Heartbleed Bug,” Mar. 07, 2025. Available: https://heartbleed.com/\n\n\n[3] C. Meyer and J. Schwenk, “Lessons Learned From Previous SSL/TLS Attacks - A Brief Chronology Of Attacks And Weaknesses,” 2013. Available: https://eprint.iacr.org/2013/049\n\n\n[4] “American fuzzy lop.” Available: https://lcamtuf.coredump.cx/afl/\n\n\n[5] “libFuzzer – a library for coverage-guided fuzz testing. — LLVM 21.0.0git documentation,” 2025. Available: https://llvm.org/docs/LibFuzzer.html\n\n\n[6] “Google/atheris.” Google, Apr. 09, 2025. Available: https://github.com/google/atheris\n\n\n[7] A. Vaswani et al., “Attention Is All You Need,” Aug. 01, 2023. doi: 10.48550/arXiv.1706.03762. Available: http://arxiv.org/abs/1706.03762\n\n\n[8] J. Wei et al., “Chain-of-Thought Prompting Elicits Reasoning in Large Language Models,” Jan. 10, 2023. doi: 10.48550/arXiv.2201.11903. Available: http://arxiv.org/abs/2201.11903\n\n\n[9] S. Yao et al., “ReAct: Synergizing Reasoning and Acting in Language Models,” Mar. 10, 2023. doi: 10.48550/arXiv.2210.03629. Available: http://arxiv.org/abs/2210.03629\n\n\n[10] S. Yao et al., “Tree of Thoughts: Deliberate Problem Solving with Large Language Models,” Dec. 03, 2023. doi: 10.48550/arXiv.2305.10601. Available: http://arxiv.org/abs/2305.10601\n\n\n[11] P. Laban, H. Hayashi, Y. Zhou, and J. Neville, “LLMs Get Lost In Multi-Turn Conversation,” May 09, 2025. doi: 10.48550/arXiv.2505.06120. Available: http://arxiv.org/abs/2505.06120\n\n\n[12] N. Perry, M. Srivastava, D. Kumar, and D. Boneh, “Do Users Write More Insecure Code with AI Assistants?” Dec. 18, 2023. doi: 10.48550/arXiv.2211.03622. Available: http://arxiv.org/abs/2211.03622\n\n\n[13] H. Chase, “LangChain.” Oct. 2022. Available: https://github.com/langchain-ai/langchain\n\n\n[14] “Langchain-ai/langgraph.” LangChain, May 21, 2025. Available: https://github.com/langchain-ai/langgraph\n\n\n[15] J. Liu, “LlamaIndex.” Nov. 2022. doi: 10.5281/zenodo.1234. Available: https://github.com/jerryjliu/llama_index\n\n\n[16] O. Khattab et al., “DSPy: Compiling Declarative Language Model Calls into Self-Improving Pipelines,” Oct. 05, 2023. doi: 10.48550/arXiv.2310.03714. Available: http://arxiv.org/abs/2310.03714\n\n\n[17] D. Ganguly, S. Iyengar, V. Chaudhary, and S. Kalyanaraman, “Proof of Thought : Neurosymbolic Program Synthesis allows Robust and Interpretable Reasoning,” Sep. 25, 2024. doi: 10.48550/arXiv.2409.17270. Available: http://arxiv.org/abs/2409.17270\n\n\n[18] A. d’Avila Garcez and L. C. Lamb, “Neurosymbolic AI: The 3rd Wave,” Dec. 16, 2020. doi: 10.48550/arXiv.2012.05876. Available: http://arxiv.org/abs/2012.05876\n\n\n[19] M. Gaur and A. Sheth, “Building Trustworthy NeuroSymbolic AI Systems: Consistency, Reliability, Explainability, and Safety,” Dec. 05, 2023. doi: 10.48550/arXiv.2312.06798. Available: http://arxiv.org/abs/2312.06798\n\n\n[20] G. Grov, J. Halvorsen, M. W. Eckhoff, B. J. Hansen, M. Eian, and V. Mavroeidis, “On the use of neurosymbolic AI for defending against cyber attacks,” Aug. 09, 2024. doi: 10.48550/arXiv.2408.04996. Available: http://arxiv.org/abs/2408.04996\n\n\n[21] A. Sheth, K. Roy, and M. Gaur, “Neurosymbolic AI – Why, What, and How,” May 01, 2023. doi: 10.48550/arXiv.2305.00813. Available: http://arxiv.org/abs/2305.00813\n\n\n[22] D. Tilwani, R. Venkataramanan, and A. P. Sheth, “Neurosymbolic AI approach to Attribution in Large Language Models,” Sep. 30, 2024. doi: 10.48550/arXiv.2410.03726. Available: http://arxiv.org/abs/2410.03726",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Background</span>"
    ]
  },
  {
    "objectID": "chapters/related.html",
    "href": "chapters/related.html",
    "title": "3  Related work",
    "section": "",
    "text": "3.1 Previous projects\nAutomated testing, automated fuzzing and automated harness creation have a long research history. Still, a lot of ground remains to be covered until true automation of these tasks is achieved. Until the introduction of transformers [1] and the 2020’s boom of commercial GPTs [2], automation regarding testing and fuzzing was mainly attempted through static and dynamic program analysis methods. These approaches are still utilized, but the fuzzing community has shifted almost entirely to researching the incorporation and employment of LLMs in the last half decade, in the name of automation [3], [4], [5], [6], [7], [8], [9], [10], [11], [12].",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Related work</span>"
    ]
  },
  {
    "objectID": "chapters/related.html#previous-projects",
    "href": "chapters/related.html#previous-projects",
    "title": "3  Related work",
    "section": "",
    "text": "3.1.1 KLEE\nKLEE [13] is a seminal and widely cited symbolic execution engine introduced in 2008 by Cadar et al. It was designed to automatically generate high-coverage test cases for programs written in C, using symbolic execution to systematically explore the control flow of a program. KLEE operates on the LLVM [14] bytecode representation of programs, allowing it to be applied to a wide range of C programs compiled to the LLVM intermediate representation.\nInstead of executing a program on concrete inputs, KLEE performs symbolic execution—that is, it runs the program on symbolic inputs, which represent all possible values simultaneously. At each conditional branch, KLEE explores both paths by forking the execution and accumulating path constraints (i.e., logical conditions on input variables) along each path. This enables it to traverse many feasible execution paths in the program, including corner cases that may be difficult to reach through random testing or manual test creation.\nWhen an execution path reaches a terminal state (e.g., a program exit, an assertion failure, or a segmentation fault), KLEE uses a constraint solver to compute concrete input values that satisfy the accumulated constraints for that path. These values form a test case that will deterministically drive the program down that specific path when executed concretely.\n\n\n3.1.2 IRIS\nIRIS [3] is a 2025 open-source neurosymbolic system for static vulnerability analysis. Given a codebase and a list of user-specified Common Weakness Enumerations (CWEs), it analyzes source code to identify paths that may correspond to known vulnerability classes. IRIS combines symbolic analysis—such as control- and data-flow reasoning—with neural models trained to generalize over code patterns. It outputs candidate vulnerable paths along with explanations and CWE references. The system operates on full repositories and supports extensible CWE definitions.\n\n\n3.1.3 FUDGE\nFUDGE [12] is a closed-source tool, made by Google, for automatic harness generation of C and C++ projects based on existing client code. It was used in conjunction with and in the improvement of Google’s OSS-Fuzz [15]. Being deployed inside Google’s infrastructure, FUDGE continuously examines Google’s internal code repository, searching for code that uses external libraries in a meaningful and “fuzzable” way (i.e. predominantly for parsing). If found, such code is sliced [16], per FUDGE, based on its Abstract Syntax Tree (AST) using LLVM’s Clang tool [14]. The above process results in a set of abstracted mostly-self-contained code snippets that make use of a library’s calls and/or API. These snippets are later synthesized into the body of a fuzz driver, with variables being replaced and the fuzz input being utilized. Each is then injected in an LLVMFuzzerTestOneInput function and finalized as a fuzzing harness. A building and evaluation phase follows for each harness, where they are executed and examined. Every passing harness along with its evaluation results is stored in FUDGE’s database, reachable to the user through a custom web-based UI.\n\n\n3.1.4 UTopia\nUTopia [8] (stylized UTopia) is another open-source automatic harness generation framework. Aside from the library code, It operates solely on user-provided unit tests since, according to [8], they are a resource of complete and correct API usage examples containing working library set-ups and tear-downs. Additionally, each of them are already close to a fuzz target, in the sense that they already examine a single and self-contained API usage pattern. Each generated harness follows the same data flow of the originating unit test. Static analysis is employed to figure out what fuzz input placement would yield the most results. It is also utilized in abstracting the tests away from the syntactical differences between testing frameworks, along with slicing and AST traversing using Clang.\n\n\n3.1.5 FuzzGen\nAnother project of Google is FuzzGen [11], this time open-source. Like FUDGE, it leverages existing client code of the target library to create fuzz targets for it. FuzzGen uses whole-system analysis, through which it creates an Abstract API Dependence Graph (A2DG). It uses the latter to automatically generate LibFuzzer-compatible harnesses. For FuzzGen to work, the user needs to provide both client code and/or tests for the API and the API library’s source code as well. FuzzGen uses the client code to infer the correct usage of the API and not its general structure, in contrast to FUDGE. FuzzGen’s workflow can be divided into three phases: 1. API usage inference. By consuming and analyzing client code and tests that concern the library under test, FuzzGen recognizes which functions belong to the library and learns its correct API usage patterns. This process is done with the help of Clang. To test if a function is actually a part of the library, a sample program is created that uses it. If the program compiles successfully, then the function is indeed a valid API call. 2. A2DG construction mechanism. For all the existing API calls, FuzzGen builds an A2DG to record the API usages and infers its intended structure. After completion, this directed graph contains all the valid API call sequences found in the client code corpus. It is built in a two-step process: First, many smaller A2DGs are created, one for each root function per client code snippet. Once such graphs have been created for all the available client code instances, they are combined to formulate the master A2DG. This graph can be seen as a template for correct usage of the library. 3. Fuzzer generator. Through the A2DG, a fuzzing harness is created. Contrary to FUDGE, FuzzGen does not create multiple “simple” harnesses but a single complex one with the goal of covering the whole of the A2DG. In other words, while FUDGE fuzzes a single API call at a time, FuzzGen’s result is a single harness that tries to fuzz the given library all at once through complex API usage.\n\n\n3.1.6 OSS-Fuzz\nOSS-Fuzz [15], [17] is a continuous, scalable and distributed cloud fuzzing solution for critical and prominent open-source projects. Developers of such software can submit their projects to OSS-Fuzz’s platform, where its harnesses are built and constantly executed. This results in multiple bug findings that are later disclosed to the primary developers and are later patched.\nOSS-Fuzz started operating in 2016, an initiative in response to the Heartbleed vulnerability [18], [19], [20]. Its hope is that through more extensive fuzzing such errors could be caught and corrected before having the chance to be exploited and thus disrupt the public digital infrastructure. So far, it has helped uncover over 10,000 security vulnerabilities and 36,000 bugs across more than 1,000 projects, significantly enhancing the quality and security of major software like Chrome, OpenSSL, and systemd.\nA project that’s part of OSS-Fuzz must have been configured as a ClusterFuzz [21] project. ClusterFuzz is the fuzzing infrastructure that OSS-Fuzz uses under the hood and depends on Google Cloud Platform services, although it can be hosted locally. Such an integration requires setting up a build pipeline, fuzzing jobs and expects a Google Developer account. Results are accessible through a web interface. ClusterFuzz, and by extension OSS-Fuzz, supports fuzzing through LibFuzzer, AFL++, Honggfuzz and FuzzTest—successor to Centipede— with the last two being Google projects [22], [23], [24], [25]. C, C++, Rust, Go, Python and Java/JVM projects are supported.\n\n\n3.1.7 OSS-Fuzz-Gen\nOSS-Fuzz-Gen (OFG) [6], [26] is Google’s current State-Of-The-Art (SOTA) project regarding automatic harness generation through LLMs. It’s purpose is to improve the fuzzing infrastructure of open-source projects that are already integrated into OSS-Fuzz. Given such a project, OSS-Fuzz-Gen uses its preexisting fuzzing harnesses and modifies them to produce new ones. Its architecture can be described as follows: 1. With an OSS-Fuzz project’s GitHub repository link, OSS-Fuzz-Gen iterates through a set of predefined build templates and generates potential build scripts for the project’s harnesses. 2. If any of them succeed they are once again compiled, this time through fuzz-introspector [27]. The latter constitutes a static analysis tool, with fuzzer developers specifically in mind. 3. Build results, old harness and fuzz-introspector report are included in a template-generated prompt, through which an LLM is called to generate a new harness. 4. The newly generated fuzz target is compiled and if it is done so successfully it begins execution inside OSS-Fuzz’s infrastructure.\nThis method proved meaningful, with code coverage in fuzz campaigns increasing thanks to the new generated fuzz drivers. In the case of [28], line coverage went from 38% to 69% without any manual interventions [26].\nIn 2024, OSS-Fuzz-Gen introduced an experimental feature for generating harnesses in previously unfuzzed projects [29]. The code for this feature resides in the experimental/from_scratch directory of the project’s GitHub repository [6], with the latest known working commit being 171aac2 and the latest overall commit being four months ago.\n\n\n3.1.8 AutoGen\nAutoGen [4] is a closed-source tool that generates new fuzzing harnesses, given only the library code and documentation. It works as following: The user specifies the function for which a harness is to be generated. AutoGen gathers information for this function—such as the function body, used header files, function calling examples—from the source code and documentation. Through specific prompt templates containing the above information, an LLM is tasked with generating a new fuzz driver, while another is tasked with generating a compilation command for said driver. If the compilation fails, both LLMs are called again to fix the problem, whether it was on the driver’s or command’s side. This loop iterates until a predefined maximum value or until a fuzz driver is successfully generated and compiled. If the latter is the case, it is then executed. If execution errors exist, the LLM responsible for the driver generation is used to correct them. If not, the pipeline has terminated and a new fuzz driver has been successfully generated.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Related work</span>"
    ]
  },
  {
    "objectID": "chapters/related.html#differences",
    "href": "chapters/related.html#differences",
    "title": "3  Related work",
    "section": "3.2 Differences",
    "text": "3.2 Differences\nOverHAuL differs, in some way, with each of the aforementioned works. Firstly, although KLEE and IRIS [3], [13] tackle the problem of automated testing and both IRIS and OverHAuL can be considered neurosymbolic AI tools, the similarities end there. None of them utilize LLMs the same way we do—with KLEE not utilizing them by default, as it precedes them chronologically—and neither are automating any part of the fuzzing process.\nWhen it comes to FUDGE, FuzzGen and UTopia [8], [11], [12], all three depend on and demand existing client code and/or unit tests. On the other hand, OverHAuL requires only the bare minimum: the library code itself. Another point of difference is that in contrast with OverHAuL, these tools operate in a linear fashion. No feedback is produced or used in any step and any point failure results in the termination of the entire run.\nOverHAuL challenges a common principle of these tools, stated explicitly in FUDGE’s paper [12]: “Choosing a suitable fuzz target (still) requires a human”. OverHAuL chooses to let the LLM, instead of the user, explore the available functions and choose one to target in its fuzz driver.\nOSS-Fuzz-Gen [6] can be considered a close counterpart of OverHAuL, and in some ways it is. A lot of inspiration was gathered from it, like for example the inclusion of static analysis and its usage in informing the LLM. Yet, OSS-Fuzz-Gen has a number of disadvantages that make it in some cases an inferior option. For one, OFG is tightly coupled with the OSS-Fuzz platform [15], which even on its own creates a plethora of issues for the common developer. To integrate their project into OSS-Fuzz, they would need to: Transform it into a ClusterFuzz project [21] and take time to write harnesses for it. Even if these prerequisites are carried out, it probably would not be enough. Per OSS-Fuzz’s documentation [17]: “To be accepted to OSS-Fuzz, an open-source project must have a significant user base and/or be critical to the global IT infrastructure”. This means that OSS-Fuzz is a viable option only for a small minority of open-source developers and maintainers. One countermeasure of the above shortcoming would be for a developer to run OSS-Fuzz-Gen locally. This unfortunately proves to be an arduous task. As it is not meant to be used standalone, OFG is not packaged in the form of a self-contained application. This makes it hard to setup and difficult to use interactively. Like in the case of FUDGE, OFG’s actions are performed linearly. No feedback is utilized nor is there graceful error handling in the case of a step’s failure. Even in the case of the experimental feature for bootstrapping unfuzzed projects, OFG’s performance varies heavily. During experimentation, a lot of generated harnesses were still wrapped either in Markdown backticks or &lt;code&gt; tags, or were accompanied with explanations inside the generated .c source file. Even if code was formatted correctly, in many cases it missed necessary headers for compilation or used undeclared functions.\nLastly, the closest counterpart to OverHAuL is AutoGen [4]. Their similarity stands in the implementation of a feedback loop between LLM and generated harness. However, most other implementation decisions remain distinct. One difference regards the fuzzed function. While AutoGen requires a target function to be specified by the user in which it narrows during its whole run, OverHAuL delegates this to the LLM, letting it explore the codebase and decide by itself the best candidate. Another difference lies in the need—and the lack of—of documentation. While AutoGen requires it to gather information for the given function, OverHAuL leans into the role of a developer by reading the related code and comments and thus avoiding any mismatches between documentation and code. Finally, the LLMs’ input is built based on predefined prompt templates, a technique also present in OSS-Fuzz-Gen. OverHAuL operates one abstraction level higher, leveraging DSPy [30] for programming instead of prompting the LLMs used.\nIn conclusion, OverHAuL constitutes an open-source tool that offers new functionality by offering a straightforward installation process, packaged as a self-contained Python package with minimal external dependencies. It also introduces novel approaches compared to previous work by\n\nImplementing a feedback mechanism between harness generation, compilation, and evaluation phases,\nUsing autonomous ReAct agents capable of codebase exploration,\nLeveraging a vector store for code consumption and retrieval.\n\nTODO να συμπεριλάβω και τα:\n\n3.2.1 IntelliGen [[20250711141156]]\nSAMPLE\nIntelliGen: Automatic Fuzz Driver Synthesis Based on Vulnerability Heuristics Zhang et al. (2021) present IntelliGen, a system for automatically synthesizing fuzz drivers by statically identifying potentially vulnerable entry-point functions within C projects. Implemented using LLVM, IntelliGen focuses on improving fuzzing efficiency by targeting code more likely to contain memory safety issues, rather than exhaustively fuzzing all available functions.\nThe system comprises two main components: the Entry Function Locator and the Fuzz Driver Synthesizer. The Entry Function Locator analyzes the project’s abstract syntax tree (AST) and classifies functions based on heuristics that indicate vulnerability. These include pointer dereferencing, calls to memory-related functions (e.g., memcpy, memset), and invocation of other internal functions. Functions that score highly on these metrics are prioritized for fuzz driver generation. The guiding insight is that entry points with fewer argument checks and more direct memory operations expose more useful program logic for fuzz testing.\nThe Fuzz Driver Synthesizer then generates harnesses for these entry points. For each target function, it synthesizes a LLVMFuzzerTestOneInput function that invokes the target with arguments derived from the fuzzer input. This process involves inferring argument types from the source code and ensuring that runtime behavior does not violate memory safety—thus avoiding invalid inputs that would cause crashes unrelated to genuine bugs.\nIntelliGen stands out by integrating static vulnerability estimation into the driver generation pipeline. Compared to prior tools like FuzzGen and FUDGE, it uses a more targeted, heuristic-based selection of functions, increasing the likelihood that fuzzing will exercise meaningful and vulnerable code paths.\n\n\n3.2.2 CKGFuzzer [[20250711203054]]\nSAMPLE\nCKGFuzzer is a fuzzing framework designed to automate the generation of effective fuzz drivers for C/C++ libraries by leveraging static analysis and large language models. Its workflow begins by parsing the target project along with any associated library APIs to construct a code knowledge graph. This involves two primary steps: first, parsing the abstract syntax tree (AST), and second, performing interprocedural program analysis. Through this process, CKGFuzzer extracts essential program elements such as data structures, function signatures, function implementations, and call relationships.\nUsing the knowledge graph, CKGFuzzer then identifies and queries meaningful API combinations, focusing on those that are either frequently invoked together or exhibit functional similarity. It generates candidate fuzz drivers for these combinations and attempts to compile them. Any compilation errors encountered during this phase are automatically repaired using heuristics and domain knowledge. A dynamically updated knowledge base, constructed from prior library usage patterns, guides both the generation and repair processes.\nOnce the drivers are successfully compiled, CKGFuzzer executes them while monitoring code coverage at the file level. It uses coverage feedback to iteratively mutate underperforming API combinations, refining them until new execution paths are discovered or a preset mutation budget is exhausted.\nFinally, any crashes triggered during fuzzing are subjected to a reasoning process based on chain-of-thought prompting. To help determine their severity and root cause, CKGFuzzer consults an LLM-generated knowledge base containing real-world examples of vulnerabilities mapped to known Common Weakness Enumeration (CWE) entries.\n\n\n3.2.3 PromptFuzz [[20250713225436]]\nSAMPLE\nLyu et al. (2024) introduce PromptFuzz [31], a system for automatically generating fuzz drivers using LLMs, with a novel focus on prompt mutation to improve coverage. The system is implemented in Rust and targets C libraries, aiming to explore more of the API surface with each iteration.\nThe workflow begins with the random selection of API functions, extracted from header file declarations. These functions are used to construct initial prompts that instruct the LLM to generate a simple program utilizing the API. Each generated program is compiled, executed, and monitored for code coverage. Programs that fail to compile or violate runtime checks (e.g., sanitizers) are discarded.\nA key innovation in PromptFuzz is coverage-guided prompt mutation. Instead of mutating generated code directly, PromptFuzz mutates the LLM prompts—selecting new combinations of API functions to target unexplored code paths. This process is guided by a power scheduling strategy that prioritizes underused or promising API functions based on feedback from previous runs.\nOnce an effective program is produced, it is transformed into a fuzz driver by replacing constants and arguments with variables derived from the fuzzer input. Multiple such drivers are embedded into a single harness, where the input determines which program variant to execute, typically via a case-switch construct.\nOverall, PromptFuzz demonstrates that prompt-level mutation enables more effective exploration of complex APIs and achieves better coverage than direct code mutations, offering a compelling direction for LLM-based automated fuzzing systems.\n\n\n\n\n[1] A. Vaswani et al., “Attention Is All You Need,” Aug. 01, 2023. doi: 10.48550/arXiv.1706.03762. Available: http://arxiv.org/abs/1706.03762\n\n\n[2] OpenAI, “ChatGPT,” 2025. Available: https://chatgpt.com\n\n\n[3] Z. Li, S. Dutta, and M. Naik, “IRIS: LLM-Assisted Static Analysis for Detecting Security Vulnerabilities,” Apr. 06, 2025. doi: 10.48550/arXiv.2405.17238. Available: http://arxiv.org/abs/2405.17238\n\n\n[4] Y. Sun, “Automated Generation and Compilation of Fuzz Driver Based on Large Language Models,” in Proceedings of the 2024 9th International Conference on Cyber Security and Information Engineering, in ICCSIE ’24. New York, NY, USA: Association for Computing Machinery, Dec. 2024, pp. 461–468. doi: 10.1145/3689236.3689272. Available: https://doi.org/10.1145/3689236.3689272\n\n\n[5] D. Wang, G. Zhou, L. Chen, D. Li, and Y. Miao, “ProphetFuzz: Fully Automated Prediction and Fuzzing of High-Risk Option Combinations with Only Documentation via Large Language Model,” Sep. 01, 2024. doi: 10.1145/3658644.3690231. Available: http://arxiv.org/abs/2409.00922\n\n\n[6] D. Liu, O. Chang, J. metzman, M. Sablotny, and M. Maruseac, “OSS-fuzz-gen: Automated fuzz target generation.” May 2024. Available: https://github.com/google/oss-fuzz-gen\n\n\n[7] H. Green and T. Avgerinos, “GraphFuzz: Library API fuzzing with lifetime-aware dataflow graphs,” in Proceedings of the 44th International Conference on Software Engineering, Pittsburgh Pennsylvania: ACM, May 2022, pp. 1070–1081. doi: 10.1145/3510003.3510228. Available: https://dl.acm.org/doi/10.1145/3510003.3510228\n\n\n[8] B. Jeong et al., “UTopia: Automatic Generation of Fuzz Driver using Unit Tests,” in 2023 IEEE Symposium on Security and Privacy (SP), May 2023, pp. 2676–2692. doi: 10.1109/SP46215.2023.10179394. Available: https://ieeexplore.ieee.org/abstract/document/10179394\n\n\n[9] Y. Deng, C. S. Xia, C. Yang, S. D. Zhang, S. Yang, and L. Zhang, “Large Language Models are Edge-Case Fuzzers: Testing Deep Learning Libraries via FuzzGPT,” Apr. 04, 2023. doi: 10.48550/arXiv.2304.02014. Available: http://arxiv.org/abs/2304.02014\n\n\n[10] Y. Deng, C. S. Xia, H. Peng, C. Yang, and L. Zhang, “Large Language Models Are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models,” in Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis, in ISSTA 2023. New York, NY, USA: Association for Computing Machinery, Jul. 2023, pp. 423–435. doi: 10.1145/3597926.3598067. Available: https://dl.acm.org/doi/10.1145/3597926.3598067\n\n\n[11] K. Ispoglou, D. Austin, V. Mohan, and M. Payer, “FuzzGen: Automatic fuzzer generation,” in 29th USENIX Security Symposium (USENIX Security 20), 2020, pp. 2271–2287. Available: https://www.usenix.org/conference/usenixsecurity20/presentation/ispoglou\n\n\n[12] D. Babić et al., “FUDGE: Fuzz driver generation at scale,” in Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, Tallinn Estonia: ACM, Aug. 2019, pp. 975–985. doi: 10.1145/3338906.3340456. Available: https://dl.acm.org/doi/10.1145/3338906.3340456\n\n\n[13] C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs,” presented at the USENIX Symposium on Operating Systems Design and Implementation, Dec. 2008. Available: https://www.semanticscholar.org/paper/KLEE%3A-Unassisted-and-Automatic-Generation-of-Tests-Cadar-Dunbar/0b93657965e506dfbd56fbc1c1d4b9666b1d01c8\n\n\n[14] “The LLVM Compiler Infrastructure Project,” 2025. Available: https://llvm.org/\n\n\n[15] A. Arya, O. Chang, J. Metzman, K. Serebryany, and D. Liu, “OSS-Fuzz.” Apr. 08, 2025. Available: https://github.com/google/oss-fuzz\n\n\n[16] N. Sasirekha, A. Edwin Robert, and M. Hemalatha, “Program Slicing Techniques and its Applications,” IJSEA, vol. 2, no. 3, pp. 50–64, Jul. 2011, doi: 10.5121/ijsea.2011.2304. Available: http://www.airccse.org/journal/ijsea/papers/0711ijsea04.pdf\n\n\n[17] “OSS-Fuzz Documentation,” 2025. Available: https://google.github.io/oss-fuzz/\n\n\n[18] CVE Program, “CVE - CVE-2014-0160,” 2014. Available: https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0160\n\n\n[19] D. Wheeler, “How to Prevent the next Heartbleed,” 2014. Available: https://dwheeler.com/essays/heartbleed.html\n\n\n[20] “Heartbleed Bug,” Mar. 07, 2025. Available: https://heartbleed.com/\n\n\n[21] “Google/clusterfuzz.” Google, Apr. 09, 2025. Available: https://github.com/google/clusterfuzz\n\n\n[22] “libFuzzer – a library for coverage-guided fuzz testing. — LLVM 21.0.0git documentation,” 2025. Available: https://llvm.org/docs/LibFuzzer.html\n\n\n[23] “Google/fuzztest.” Google, Jul. 10, 2025. Available: https://github.com/google/fuzztest\n\n\n[24] “Google/honggfuzz.” Google, Jul. 10, 2025. Available: https://github.com/google/honggfuzz\n\n\n[25] M. Heuse, H. Eißfeldt, A. Fioraldi, and D. Maier, “AFL++.” Jan. 2022. Available: https://github.com/AFLplusplus/AFLplusplus\n\n\n[26] D. Liu, J. Metzman, O. Chang, and G. O. S. S. Team, “AI-Powered Fuzzing: Breaking the Bug Hunting Barrier,” Aug. 16, 2023. Available: https://security.googleblog.com/2023/08/ai-powered-fuzzing-breaking-bug-hunting.html\n\n\n[27] “Ossf/fuzz-introspector.” Open Source Security Foundation (OpenSSF), Jun. 30, 2025. Available: https://github.com/ossf/fuzz-introspector\n\n\n[28] L. Thomason, “Leethomason/Tinyxml2.” Jul. 10, 2025. Available: https://github.com/leethomason/tinyxml2\n\n\n[29] OSS-Fuzz Maintainers, “Introducing LLM-based harness synthesis for unfuzzed projects,” May 27, 2024. Available: https://blog.oss-fuzz.com/posts/introducing-llm-based-harness-synthesis-for-unfuzzed-projects/\n\n\n[30] O. Khattab et al., “DSPy: Compiling Declarative Language Model Calls into Self-Improving Pipelines,” Oct. 05, 2023. doi: 10.48550/arXiv.2310.03714. Available: http://arxiv.org/abs/2310.03714\n\n\n[31] Y. Lyu, Y. Xie, P. Chen, and H. Chen, “Prompt Fuzzing for Fuzz Driver Generation,” May 29, 2024. doi: 10.48550/arXiv.2312.17677. Available: http://arxiv.org/abs/2312.17677",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Related work</span>"
    ]
  },
  {
    "objectID": "chapters/overhaul.html",
    "href": "chapters/overhaul.html",
    "title": "4  Overview",
    "section": "",
    "text": "4.1 Architecture",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "chapters/overhaul.html#architecture",
    "href": "chapters/overhaul.html#architecture",
    "title": "4  Overview",
    "section": "",
    "text": "System diagram\nMain Library Architecture/Structure\nLLM usage\n\nPrompting techniques used (callback to Section 2.2.1).\n\nStatic analysis\nCode localization(?)\nFuzzers\nGitHub Workflow/Usage\n“Ieration budget”",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "chapters/results.html",
    "href": "chapters/results.html",
    "title": "5  Evaluation",
    "section": "",
    "text": "5.1 Benchmarks\nResults from integration with 10/100 open-source C/C++ projects.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Evaluation</span>"
    ]
  },
  {
    "objectID": "chapters/results.html#performance",
    "href": "chapters/results.html#performance",
    "title": "5  Evaluation",
    "section": "5.2 Performance",
    "text": "5.2 Performance",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Evaluation</span>"
    ]
  },
  {
    "objectID": "chapters/results.html#issues",
    "href": "chapters/results.html#issues",
    "title": "5  Evaluation",
    "section": "5.3 Issues",
    "text": "5.3 Issues",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Evaluation</span>"
    ]
  },
  {
    "objectID": "chapters/results.html#future-work",
    "href": "chapters/results.html#future-work",
    "title": "5  Evaluation",
    "section": "5.4 Future work",
    "text": "5.4 Future work\n\n5.4.1 Technical future work\n\n\n5.4.2 Architectural future work/extensions\n\nBuild system\nMore (static) analysis tolls integrations\nGeneral localization problem",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Evaluation</span>"
    ]
  },
  {
    "objectID": "chapters/future.html",
    "href": "chapters/future.html",
    "title": "6  Future Work",
    "section": "",
    "text": "6.1 Enhancements to Core Features\nThe prototype implementation of OverHAuL offers a compelling demonstration of its potential to automate the fuzzing process for open-source libraries, providing tangible benefits to developers and maintainers alike. This initial version successfully validates the core design principles underpinning OverHAuL, showcasing its ability to streamline and enhance the software testing workflow through automated generation of fuzz drivers using large language models. Nevertheless, while these foundational capabilities lay a solid groundwork, numerous avenues exist for further expansion, refinement, and rigorous evaluation to fully realize the tool’s potential and adapt to evolving challenges in software quality assurance.\nEnhancing OverHAuL’s core functionality represents a primary direction for future development. First, expanding support to encompass a wider array of build systems commonly employed in C and C++ projects—such as GNU Make, CMake, Meson, and Ninja [1], [2], [3], [4]—would significantly broaden the scope of libraries amenable to automated fuzzing using OverHAuL. This advancement would enable OverHAuL to scale effectively and be applied to larger, more complex codebases, thereby increasing its practical utility and impact.\nSecond, integrating additional fuzzing engines beyond LibFuzzer stands out as a strategic enhancement. Incorporation of widely adopted fuzzers like AFL++ [5] could diversify the fuzzing strategies available to OverHAuL, while exploring more experimental tools such as GraphFuzz [6] may pioneer specialized approaches for certain code patterns or architectures. Multi-engine support would also facilitate extending language coverage, for instance by incorporating fuzzers tailored to other programming ecosystems—for example, Google’s Atheris for Python projects [7]. Such versatility would position OverHAuL as a more universal fuzzing automation platform.\nThird, the evaluation component of OverHAuL presents an opportunity for refinement through more sophisticated analysis techniques. Beyond the current criteria, incorporating dynamic metrics such as differential code coverage tracking between generated fuzz harnesses would yield deeper insights into test quality and coverage completeness. This quantitative evaluation could guide iterative improvements in fuzz driver generation and overall testing effectiveness.\nFinally, OverHAuL’s methodology could be extended to leverage existing client codebases and unit tests in addition to the library source code itself, resources that for now OverHAuL leaves untapped. Inspired by approaches like those found in FUDGE and FuzzGen [8], [9], this enhancement would enable the tool to exploit programmer-written usage scenarios as seeds or contexts, potentially generating more meaningful and targeted fuzz inputs. Incorporating these richer information sources would likely improve the efficacy of fuzzing campaigns and uncover subtler bugs.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Future Work</span>"
    ]
  },
  {
    "objectID": "chapters/future.html#experimentation-with-large-language-models-and-data-representation",
    "href": "chapters/future.html#experimentation-with-large-language-models-and-data-representation",
    "title": "6  Future Work",
    "section": "6.2 Experimentation with Large Language Models and Data Representation",
    "text": "6.2 Experimentation with Large Language Models and Data Representation\nOverHAuL’s reliance on large language models (LLMs) invites comprehensive experimentation with different providers and architectures to assess their comparative strengths and limitations. Conducting empirical evaluations across leading models—such as OpenAI’s o1 and o3 families and Anthropic’s Claude Opus 4—will provide valuable insights into their capabilities, cost-efficiency, and suitability for fuzz driver synthesis. Additionally, specialized code-focused LLMs, including generative and fill-in models like Codex-1 and CodeGen [10], [11], [12], merit exploration due to their targeted optimization for source code generation and understanding.\nAnother dimension worthy of investigation concerns the granularity of code chunking employed during the given project’s code processing stage. Whereas the current approach partitions code at the function level, experimenting with more nuanced segmentation strategies—such as splitting per step inside a function, as a finer-grained technique—could improve the semantic coherence of stored representations and enhance retrieval relevance during fuzz driver generation. This line of inquiry has the potential to optimize model input preparation and ultimately improve output quality.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Future Work</span>"
    ]
  },
  {
    "objectID": "chapters/future.html#comprehensive-evaluation-and-benchmarking",
    "href": "chapters/future.html#comprehensive-evaluation-and-benchmarking",
    "title": "6  Future Work",
    "section": "6.3 Comprehensive Evaluation and Benchmarking",
    "text": "6.3 Comprehensive Evaluation and Benchmarking\nTo thoroughly establish OverHAuL’s effectiveness, extensive large-scale evaluation beyond the initial 10-project corpus is imperative. Applying the tool to repositories indexed in the clib package manager [13], which encompasses hundreds of C libraries, would test scalability and robustness across diverse real-world settings. Such a broad benchmark would also enable systematic comparisons against state-of-the-art automated fuzzing frameworks like OSS-Fuzz-Gen and AutoGen, elucidating OverHAuL’s relative strengths and identifying areas for improvement [14], [15].\nComplementing broad benchmarking, detailed ablation studies dissecting the contributions of individual pipeline components and algorithmic choices will yield critical insights into what drives OverHAuL’s performance. Understanding the impact of each module will guide targeted optimizations and support evidence-based design decisions.\nFurthermore, an economic analysis exploring resource consumption—such as API token usage and associated monetary costs—relative to fuzzing effectiveness would be valuable for assessing the practical viability of integrating LLM-based fuzz driver generation into continuous integration processes.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Future Work</span>"
    ]
  },
  {
    "objectID": "chapters/future.html#practical-deployment-and-community-engagement",
    "href": "chapters/future.html#practical-deployment-and-community-engagement",
    "title": "6  Future Work",
    "section": "6.4 Practical Deployment and Community Engagement",
    "text": "6.4 Practical Deployment and Community Engagement\nFrom a usability perspective, embedding OverHAuL within a GitHub Actions workflow represents a practical and impactful enhancement, enabling seamless integration with developers’ existing toolchains and continuous integration pipelines. This would promote wider adoption by reducing barriers to entry and fostering real-time feedback during code development cycles.\nAdditionally, establishing a mechanism to generate and submit automated pull requests (PRs) to the maintainers of fuzzed libraries—highlighting detected bugs and proposing patches—would not only validate OverHAuL’s findings but also contribute tangible improvements to open-source software quality. This collaborative feedback loop epitomizes the symbiosis between automated testing tools and the open-source community. As an initial step, developing targeted PRs for the projects where bugs were discovered during OverHAuL’s development would help facilitate practical follow-up and improvements.\n\n\n\n\n[1] A. Cedilnik, B. Hoffman, B. King, K. Martin, and A. Neundorf, “CMake - Upgrade Your Software Build System.” 2000. Available: https://cmake.org/\n\n\n[2] S. I. Feldman, “Make — a program for maintaining computer programs,” Software: Practice and Experience, vol. 9, no. 4, pp. 255–265, 1979, doi: 10.1002/spe.4380090402. Available: https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380090402\n\n\n[3] E. Martin, “Ninja-build/ninja.” ninja-build, Jul. 14, 2025. Available: https://github.com/ninja-build/ninja\n\n\n[4] J. Pakkanen, “Mesonbuild/meson.” The Meson Build System, Jul. 14, 2025. Available: https://github.com/mesonbuild/meson\n\n\n[5] M. Heuse, H. Eißfeldt, A. Fioraldi, and D. Maier, “AFL++.” Jan. 2022. Available: https://github.com/AFLplusplus/AFLplusplus\n\n\n[6] H. Green and T. Avgerinos, “GraphFuzz: Library API fuzzing with lifetime-aware dataflow graphs,” in Proceedings of the 44th International Conference on Software Engineering, Pittsburgh Pennsylvania: ACM, May 2022, pp. 1070–1081. doi: 10.1145/3510003.3510228. Available: https://dl.acm.org/doi/10.1145/3510003.3510228\n\n\n[7] “Google/atheris.” Google, Apr. 09, 2025. Available: https://github.com/google/atheris\n\n\n[8] K. Ispoglou, D. Austin, V. Mohan, and M. Payer, “FuzzGen: Automatic fuzzer generation,” in 29th USENIX Security Symposium (USENIX Security 20), 2020, pp. 2271–2287. Available: https://www.usenix.org/conference/usenixsecurity20/presentation/ispoglou\n\n\n[9] D. Babić et al., “FUDGE: Fuzz driver generation at scale,” in Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, Tallinn Estonia: ACM, Aug. 2019, pp. 975–985. doi: 10.1145/3338906.3340456. Available: https://dl.acm.org/doi/10.1145/3338906.3340456\n\n\n[10] E. Nijkamp, H. Hayashi, C. Xiong, S. Savarese, and Y. Zhou, “CodeGen2: Lessons for training llms on programming and natural languages,” ICLR, 2023.\n\n\n[11] E. Nijkamp et al., “CodeGen: An open large language model for code with multi-turn program synthesis,” ICLR, 2023.\n\n\n[12] OpenAI, “Introducing Codex,” May 16, 2025. Available: https://openai.com/index/introducing-codex/\n\n\n[13] “Clib Packages,” 2025. Available: https://github.com/clibs/clib/wiki/Packages\n\n\n[14] D. Liu, O. Chang, J. metzman, M. Sablotny, and M. Maruseac, “OSS-fuzz-gen: Automated fuzz target generation.” May 2024. Available: https://github.com/google/oss-fuzz-gen\n\n\n[15] Y. Sun, “Automated Generation and Compilation of Fuzz Driver Based on Large Language Models,” in Proceedings of the 2024 9th International Conference on Cyber Security and Information Engineering, in ICCSIE ’24. New York, NY, USA: Association for Computing Machinery, Dec. 2024, pp. 461–468. doi: 10.1145/3689236.3689272. Available: https://doi.org/10.1145/3689236.3689272",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Future Work</span>"
    ]
  },
  {
    "objectID": "chapters/discussion.html",
    "href": "chapters/discussion.html",
    "title": "7  Discussion",
    "section": "",
    "text": "more powerful llms -&gt; better results\nopen source libraries might have been in the training data results for closed source libraries could be worse this could be mitigated with llm fine-tuning",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Discussion</span>"
    ]
  },
  {
    "objectID": "chapters/conclusion.html",
    "href": "chapters/conclusion.html",
    "title": "8  Conclusion",
    "section": "",
    "text": "8.1 Acknowledgements\nRecap\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  },
  {
    "objectID": "chapters/refs.html",
    "href": "chapters/refs.html",
    "title": "Bibliography",
    "section": "",
    "text": "[1] “American fuzzy lop.” Available:\nhttps://lcamtuf.coredump.cx/afl/\n\n\n[2] M.\nHeuse, H. Eißfeldt, A. Fioraldi, and D. Maier,\n“AFL++.” Jan. 2022. Available: https://github.com/AFLplusplus/AFLplusplus\n\n\n[3] “Google/atheris.” Google, Apr. 09,\n2025. Available: https://github.com/google/atheris\n\n\n[4] A.\nCedilnik, B. Hoffman, B. King, K. Martin, and A. Neundorf,\n“CMake - Upgrade Your Software Build\nSystem.” 2000. Available: https://cmake.org/\n\n\n[5] J.\nWei et al., “Chain-of-Thought Prompting Elicits\nReasoning in Large Language Models,” Jan. 10,\n2023. doi: 10.48550/arXiv.2201.11903.\nAvailable: http://arxiv.org/abs/2201.11903\n\n\n[6] OpenAI, “ChatGPT,”\n2025. Available: https://chatgpt.com\n\n\n[7] “Clib Packages,”\n2025. Available: https://github.com/clibs/clib/wiki/Packages\n\n\n[8] “Google/clusterfuzz.” Google, Apr.\n09, 2025. Available: https://github.com/google/clusterfuzz\n\n\n[9] O.\nKhattab et al., “DSPy: Compiling\nDeclarative Language Model Calls into Self-Improving\nPipelines,” Oct. 05, 2023. doi: 10.48550/arXiv.2310.03714.\nAvailable: http://arxiv.org/abs/2310.03714\n\n\n[10] S.\nI. Feldman, “Make — a program for maintaining computer\nprograms,” Software: Practice and Experience, vol. 9,\nno. 4, pp. 255–265, 1979, doi: 10.1002/spe.4380090402.\nAvailable: https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380090402\n\n\n[11] D.\nBabić et al., “FUDGE: Fuzz driver generation\nat scale,” in Proceedings of the 2019 27th ACM Joint\nMeeting on European Software Engineering Conference\nand Symposium on the Foundations of\nSoftware Engineering, Tallinn Estonia: ACM, Aug. 2019,\npp. 975–985. doi: 10.1145/3338906.3340456.\nAvailable: https://dl.acm.org/doi/10.1145/3338906.3340456\n\n\n[12] “Ossf/fuzz-introspector.” Open\nSource Security Foundation (OpenSSF), Jun. 30, 2025. Available: https://github.com/ossf/fuzz-introspector\n\n\n[13] K.\nIspoglou, D. Austin, V. Mohan, and M. Payer,\n“FuzzGen: Automatic fuzzer\ngeneration,” in 29th USENIX Security Symposium\n(USENIX Security 20), 2020, pp. 2271–2287. Available:\nhttps://www.usenix.org/conference/usenixsecurity20/presentation/ispoglou\n\n\n[14] Y.\nDeng, C. S. Xia, C. Yang, S. D. Zhang, S. Yang, and L. Zhang,\n“Large Language Models are Edge-Case\nFuzzers: Testing Deep Learning Libraries via\nFuzzGPT,” Apr. 04, 2023. doi: 10.48550/arXiv.2304.02014.\nAvailable: http://arxiv.org/abs/2304.02014\n\n\n[15] “Google/fuzztest.” Google, Jul.\n10, 2025. Available: https://github.com/google/fuzztest\n\n\n[16] D.\nGanguly, S. Iyengar, V. Chaudhary, and S. Kalyanaraman, “Proof of\nThought : Neurosymbolic Program Synthesis\nallows Robust and Interpretable\nReasoning,” Sep. 25, 2024. doi: 10.48550/arXiv.2409.17270.\nAvailable: http://arxiv.org/abs/2409.17270\n\n\n[17] A.\nd’Avila Garcez and L. C. Lamb, “Neurosymbolic AI:\nThe 3rd Wave,” Dec. 16, 2020. doi: 10.48550/arXiv.2012.05876.\nAvailable: http://arxiv.org/abs/2012.05876\n\n\n[18] M.\nGaur and A. Sheth, “Building Trustworthy NeuroSymbolic AI\nSystems: Consistency, Reliability,\nExplainability, and Safety,” Dec. 05,\n2023. doi: 10.48550/arXiv.2312.06798.\nAvailable: http://arxiv.org/abs/2312.06798\n\n\n[19] H.\nGreen and T. Avgerinos, “GraphFuzz: Library\nAPI fuzzing with lifetime-aware dataflow graphs,” in\nProceedings of the 44th International Conference on\nSoftware Engineering, Pittsburgh Pennsylvania: ACM,\nMay 2022, pp. 1070–1081. doi: 10.1145/3510003.3510228.\nAvailable: https://dl.acm.org/doi/10.1145/3510003.3510228\n\n\n[20] G.\nGrov, J. Halvorsen, M. W. Eckhoff, B. J. Hansen, M. Eian, and V.\nMavroeidis, “On the use of neurosymbolic AI for\ndefending against cyber attacks,” Aug. 09, 2024. doi: 10.48550/arXiv.2408.04996.\nAvailable: http://arxiv.org/abs/2408.04996\n\n\n[21] “Heartbleed Bug,”\nMar. 07, 2025. Available: https://heartbleed.com/\n\n\n[22] CVE Program, “CVE -\nCVE-2014-0160,” 2014. Available: https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0160\n\n\n[23] “Google/honggfuzz.” Google, Jul.\n10, 2025. Available: https://github.com/google/honggfuzz\n\n\n[24] Z.\nLi, S. Dutta, and M. Naik, “IRIS: LLM-Assisted\nStatic Analysis for Detecting Security\nVulnerabilities,” Apr. 06, 2025. doi: 10.48550/arXiv.2405.17238.\nAvailable: http://arxiv.org/abs/2405.17238\n\n\n[25] C.\nCadar, D. Dunbar, and D. Engler, “KLEE:\nUnassisted and Automatic Generation of\nHigh-Coverage Tests for Complex Systems\nPrograms,” presented at the USENIX Symposium\non Operating Systems Design and\nImplementation, Dec. 2008. Available: https://www.semanticscholar.org/paper/KLEE%3A-Unassisted-and-Automatic-Generation-of-Tests-Cadar-Dunbar/0b93657965e506dfbd56fbc1c1d4b9666b1d01c8\n\n\n[26] P.\nLaban, H. Hayashi, Y. Zhou, and J. Neville, “LLMs Get Lost\nIn Multi-Turn Conversation,” May 09, 2025. doi: 10.48550/arXiv.2505.06120.\nAvailable: http://arxiv.org/abs/2505.06120\n\n\n[27] H.\nChase, “LangChain.” Oct. 2022. Available: https://github.com/langchain-ai/langchain\n\n\n[28] “Langchain-ai/langgraph.”\nLangChain, May 21, 2025. Available: https://github.com/langchain-ai/langgraph\n\n\n[29] “libFuzzer –\na library for coverage-guided fuzz testing. — LLVM\n21.0.0git documentation,” 2025. Available: https://llvm.org/docs/LibFuzzer.html\n\n\n[30] D.\nLiu, J. Metzman, O. Chang, and G. O. S. S. Team, “AI-Powered\nFuzzing: Breaking the Bug Hunting\nBarrier,” Aug. 16, 2023. Available: https://security.googleblog.com/2023/08/ai-powered-fuzzing-breaking-bug-hunting.html\n\n\n[31] J.\nLiu, “LlamaIndex.” Nov. 2022. doi: 10.5281/zenodo.1234.\nAvailable: https://github.com/jerryjliu/llama_index\n\n\n[32] “The LLVM Compiler Infrastructure\nProject,” 2025. Available: https://llvm.org/\n\n\n[33] Y.\nLyu, Y. Xie, P. Chen, and H. Chen, “Prompt Fuzzing\nfor Fuzz Driver Generation,” May 29, 2024. doi: 10.48550/arXiv.2312.17677.\nAvailable: http://arxiv.org/abs/2312.17677\n\n\n[34] V.\nJ. M. Manes et al., “The Art,\nScience, and Engineering of\nFuzzing: A Survey,” Apr. 07, 2019. doi:\n10.48550/arXiv.1812.00140.\nAvailable: http://arxiv.org/abs/1812.00140\n\n\n[35] E.\nMartin, “Ninja-build/ninja.” ninja-build, Jul. 14, 2025.\nAvailable: https://github.com/ninja-build/ninja\n\n\n[36] C.\nMeyer and J. Schwenk, “Lessons Learned From Previous\nSSL/TLS Attacks - A Brief Chronology Of\nAttacks And Weaknesses,” 2013. Available: https://eprint.iacr.org/2013/049\n\n\n[37] E.\nNijkamp et al., “CodeGen: An\nopen large language model for code with multi-turn program\nsynthesis,” ICLR, 2023.\n\n\n[38] E.\nNijkamp, H. Hayashi, C. Xiong, S. Savarese, and Y. Zhou,\n“CodeGen2: Lessons for training llms on\nprogramming and natural languages,” ICLR, 2023.\n\n\n[39] OpenAI, “Introducing\nCodex,” May 16, 2025. Available: https://openai.com/index/introducing-codex/\n\n\n[40] A.\nArya, O. Chang, J. Metzman, K. Serebryany, and D. Liu,\n“OSS-Fuzz.” Apr. 08, 2025. Available: https://github.com/google/oss-fuzz\n\n\n[41] D.\nLiu, O. Chang, J. metzman, M. Sablotny, and M. Maruseac, “OSS-fuzz-gen: Automated fuzz target\ngeneration.” May 2024. Available: https://github.com/google/oss-fuzz-gen\n\n\n[42] OSS-Fuzz Maintainers, “Introducing LLM-based harness synthesis for unfuzzed\nprojects,” May 27, 2024. Available: https://blog.oss-fuzz.com/posts/introducing-llm-based-harness-synthesis-for-unfuzzed-projects/\n\n\n[43] “OSS-Fuzz\nDocumentation,” 2025. Available: https://google.github.io/oss-fuzz/\n\n\n[44] J.\nPakkanen, “Mesonbuild/meson.” The Meson Build System, Jul.\n14, 2025. Available: https://github.com/mesonbuild/meson\n\n\n[45] N.\nPerry, M. Srivastava, D. Kumar, and D. Boneh, “Do Users\nWrite More Insecure Code with AI Assistants?”\nDec. 18, 2023. doi: 10.48550/arXiv.2211.03622.\nAvailable: http://arxiv.org/abs/2211.03622\n\n\n[46] D.\nWang, G. Zhou, L. Chen, D. Li, and Y. Miao,\n“ProphetFuzz: Fully Automated Prediction\nand Fuzzing of High-Risk Option Combinations\nwith Only Documentation via Large Language\nModel,” Sep. 01, 2024. doi: 10.1145/3658644.3690231.\nAvailable: http://arxiv.org/abs/2409.00922\n\n\n[47] S.\nYao et al., “ReAct: Synergizing\nReasoning and Acting in Language\nModels,” Mar. 10, 2023. doi: 10.48550/arXiv.2210.03629.\nAvailable: http://arxiv.org/abs/2210.03629\n\n\n[48] N.\nSasirekha, A. Edwin Robert, and M. Hemalatha, “Program\nSlicing Techniques and its\nApplications,” IJSEA, vol. 2, no. 3, pp.\n50–64, Jul. 2011, doi: 10.5121/ijsea.2011.2304.\nAvailable: http://www.airccse.org/journal/ijsea/papers/0711ijsea04.pdf\n\n\n[49] A.\nSheth, K. Roy, and M. Gaur, “Neurosymbolic AI –\nWhy, What, and How,” May\n01, 2023. doi: 10.48550/arXiv.2305.00813.\nAvailable: http://arxiv.org/abs/2305.00813\n\n\n[50] Y.\nSun, “Automated Generation and\nCompilation of Fuzz Driver Based on\nLarge Language Models,” in Proceedings of the\n2024 9th International Conference on Cyber\nSecurity and Information Engineering, in\nICCSIE ’24. New York, NY, USA: Association for Computing\nMachinery, Dec. 2024, pp. 461–468. doi: 10.1145/3689236.3689272.\nAvailable: https://doi.org/10.1145/3689236.3689272\n\n\n[51] L.\nThomason, “Leethomason/Tinyxml2.” Jul. 10, 2025. Available:\nhttps://github.com/leethomason/tinyxml2\n\n\n[52] D.\nTilwani, R. Venkataramanan, and A. P. Sheth, “Neurosymbolic\nAI approach to Attribution in Large\nLanguage Models,” Sep. 30, 2024. doi: 10.48550/arXiv.2410.03726.\nAvailable: http://arxiv.org/abs/2410.03726\n\n\n[53] Y.\nDeng, C. S. Xia, H. Peng, C. Yang, and L. Zhang, “Large\nLanguage Models Are Zero-Shot Fuzzers: Fuzzing\nDeep-Learning Libraries via Large Language\nModels,” in Proceedings of the 32nd ACM SIGSOFT\nInternational Symposium on Software Testing and\nAnalysis, in ISSTA 2023. New York, NY,\nUSA: Association for Computing Machinery, Jul. 2023, pp. 423–435. doi:\n10.1145/3597926.3598067.\nAvailable: https://dl.acm.org/doi/10.1145/3597926.3598067\n\n\n[54] B.\nJeong et al., “UTopia: Automatic\nGeneration of Fuzz Driver using Unit\nTests,” in 2023 IEEE Symposium on\nSecurity and Privacy (SP),\nMay 2023, pp. 2676–2692. doi: 10.1109/SP46215.2023.10179394.\nAvailable: https://ieeexplore.ieee.org/abstract/document/10179394\n\n\n[55] A.\nVaswani et al., “Attention Is All You\nNeed,” Aug. 01, 2023. doi: 10.48550/arXiv.1706.03762.\nAvailable: http://arxiv.org/abs/1706.03762\n\n\n[56] D.\nWheeler, “How to Prevent the next\nHeartbleed,” 2014. Available: https://dwheeler.com/essays/heartbleed.html\n\n\n[57] S.\nYao et al., “Tree of Thoughts:\nDeliberate Problem Solving with Large Language\nModels,” Dec. 03, 2023. doi: 10.48550/arXiv.2305.10601.\nAvailable: http://arxiv.org/abs/2305.10601",
    "crumbs": [
      "Bibliography"
    ]
  }
]